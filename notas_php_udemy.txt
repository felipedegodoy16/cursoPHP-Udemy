o PHP é dividido em duas vertentes:
- Programação Backend: criação de sites dinêmicos, conexão e interação com banco de dados, geração de gráficos, documentos de XML e PDF
- Scripts de linha de comando: rodar scripts para que ações sejam executadas no computador ou remotamente, administração de sistema ou até mesmo CRONs (rotinas que rodam em paralelo sem precisar que nós executemos)

- É uma linguagem de programação que foi desenvolvida para deixar o HTML dinâmico
- Linguagem de script e open source
- Foco em desenvolvimento web
- Seus programas são executadas em server side (backend)
- PHP significa: Personal Home Page (P) e Hypertext Preprocessor (HP)

o PHP interpreta todo o bloco de código que estiver entre as tags de PHP
- a abertura é <?php
- e o fechamento é ?>
- cada linha de código termina com ;
- todo o código dentro destas tags será executado pelo PHP, e após isso será impresso na tela

//////////////////////////////////////////////////////////////////////////////////////////////////

Funções que vem com o PHP
- phpinfo() -> mostra as dependências do PHP que estão instaladas na máquina, mostra basicamente todas as informações sobre o PHP
- is_int() -> verificar se o dado é do tipo inteiro, o retorno é um booleano
- is_float() -> verificar se o dado é do tipo float, o retorno é um booleano
- is_string() -> verificar se o dado é do tipo string, o retorno é um booleano
- is_bool() -> verificar se o dado é do tipo booleano, o retorno é um booleano
- is_null() -> verificar se o dado é NULL, o retorno é um booleano
- gettype() -> retorna o tipo de dado de algo
- array_push() -> inserir elemento dentro de um array, (array, elemento)
- implode() -> passado dois parâmetros que você pode utilizar para criar uma string com um array, ("parametro que quer juntar ao array", $array) EX: implode(", ", $arr) -> Teste, Opa, Legal
- func_get_arg -> retorna uma lista com os argumentos de uma função
- func_num_args -> retorna o número de argumentos de uma função
- strlen() -> conta o número de caracteresda string passada por parâmetro
- strtoupper() -> transforma o que for passado como parâmetro para letras maiúsculas
- strtolower() -> transforma o que for passado como parâmetro para letras minúsculas
- var_dump() e print_r() -> funções depuradoras, as duas apresentam os dados de forma semelhante, porém o var_dump() exibe de uma forma 'human_readable', da mais informações, desenvolvedores preferem ele por isso
- print() -> para imprimir aquilo que é passado como parâmetro a ele, funciona igual ao echo
- trim() -> limpa espaços antes e depois da string, é passado a string como parâmetro para ele
- ltrim() -> limpa os espaços da esquerda da string (left trim), é passado a string como parâmetro para ele
- rtrim() -> limpa os espaços da direita da string (right trim), é passado a string como parâmetro para ele
- ucfirst() -> altera a primeira letra da string para maiúscula, é passado a string como parâmetro
- ucwords() -> altera a primeira letra de cada palavra da string para maiúscula, é passado a string como parâmetro
- strip_tags() -> altera uma string poluída, por exemplo, com tags HTML para uma string com apenas textos, é passado a string como parâmetro da função
- substr() -> função para pegar uma parte específica de uma string, (str, ini, fim) str = string que você tem, ini = índice que inicia o que você quer pegar, fim = número de caracteres que precisa pegar a partir do início, se omitir o fim ele pega a partir do ini até o final da string e se o fim for negativo ele pega o final da string menos o número de caracteres que foi passado, então se fim = -3 ele pega o fim menos os 3 últimos caracteres
- strrev() -> inverte uma string, é passado a string como parâmetro e ela é invertida
- str_repeat() -> usado para repetir a string, é passado por parâmetro a string e o número de vezes que se repetirá
- explode() -> usado para transformar a string em um array, é passado a string como parâmetro e o delimitador para se criar os índices EX: (" ", "Teste Teste") o delimitador é o espaço, converterá essa string em um array com dois índices [0] => Teste, [1] => Teste
- implode() -> usado para transformar um array em uma string, é passado o separador e o array para se criar a string EX: (" ", ["Teste", "Teste"]) o separador é o espaço e o array é o que vem depois
- strpos() - podemos encontrar algum texto na string, se recebermos algum valor é que o texto foi encontrado, e este valor é o índice inicial, se retornar false, o texto procurado não existe na string, é passado a string como parâmetro e o texto que quero achar dentro da string, ele procura também uma parte da string não precisa ser uma palavra inteira
- strrpos() - igual ao strpos(), mas, esse encontra a última ocorrência de um texto na string, o strpos() retornava o primeiro que ele achava que saciasse aquele texto passado, o strrpos() retorna o último que sacia
- strstr() -> usado para retornar a partir de um ponto da string até o final dela, é passado a string como parâmetro e a partir de onde ele irá pegar, EX: strstr($str, "resto"), vai pegar desde resto até o final da string, ou irá retornar false se não achar aquela string
- parse_url() -> usado para decompor uma URL, recebemos um array com todas as parter que a URL tem, alguns elementos que podem ser retornados são: protocolo, host, parâmetros
- range() -> função para criar um array rapidamente, basta passar como parâmetros o valor inicial, o valor final e se quiser o passo que ele irá, se essa última informação for ignorada ele fará de 1 em 1
- count() -> retorna o número de elementos de um array, é passado o array como parâmetro para essa função
- list() -> usado para desconstruir um array, é passado por parâmetro as variáveis que quero criar e na frente o array que uero pegar as informações EX: list($nome, $idade, $profissao) = $pessoa
- array_slice() -> podemos resgatar uma faixa de elementos, é passado 3 parâmetros para essa função, sendo o array, o índice inicial e número de elementos que queremos resgatar, assim como o substring se o último parâmetro for omitido ele pega até o final do array e se o parâmetro for negativo ele pega do final menos o número de elementos que foi passado
- array_splice() -> remover elementos de um array, passado como parâmetro o array, índice inicial e quantos elementos queremos remover, igual o slice
- array_chunk() -> dividir um array grande em diversos arrays de número de elementos iguais, passamos o array e o número de elementos que cada array deve ter 
- array_keys() -> usado no array associativo, retorna as chaves do array em formato de outro array, é passado por parâmetro apenas o array associativo
- array_values() -> usado no array associativo, retorna os valores do array em formato de outro array, é passado por parâmetro apenas o array associativo
- array_key_exists() -> verificar se uma chave específica existe dentro daquele array associativo, é passado por parâmetro a chave que quero verificar se existe e o array EX: array_key_exists("nome", $arr), retorna um booleano
- isset() -> usado também para verificar se algo existe, igual o array_key_exists(), EX: isset($arr['nome']), verifica se a chave nome existe dentro do array, usado para variáveis também
- extract() -> criar variáveis com o array associativo, igual o list, mas esse é para arrays associativos, o nome da chave será o nome da variável, se houver uma variável com o mesmo nome da chave a mesma será sobrescrita pelo valor que tiver no array, é passado apenas o array como parâmetro
- compact() -> podemos criar um array a partir de variáveis, onde o nome da variável será a chave e seu valor o valor mesmo, é passado por parâmetro as variáveis porém, em forma de string, EX: $carro = compact("marca", "motor") // as variáveis eram ($marca, $motor)
- foreach() -> para arrays associativos podemos usar a notação (chave => valor) para acessar rapidamente um valor no array associativo, para arrays normais é passado por parâmetro o array e um nome qualquer que vai ser o valor de cada índice, já para arrays associativos é passado o array mais um nome qualquer que representa a chave => um nome qualquer que representa o valor
- array_reduce() -> tem como objetivo reduzir um array a apenas um valor, geralmente é usado uma segunda função dentro dessa função para que algum processo seja executado e fique apenas um valor EX: function soma($a, $b) { return $a + $b; } array_reduce($arr, "soma") // ele vai somar todos os índices do array e retornar o resultado
- in_array() -> verifica se um item passado por parâmetro está no array, é passado o item e o array como parâmetros, o retorno é um booleano true se encontrar o item e false se não encontrar
- sort() -> ordenar de forma crescente um array, é passado por parâmetro o array que queremos ordenar, não é preciso colocá-lo dentro de outra variável, a organização ocorre dentro dele mesmo, se for um array com strings ele organiza em ordem alfabética
- rsort() -> ordenar de forma decrescente um array, é passado por parâmetro o array que queremos ordenar, não é preciso colocá-lo dentro de outra variável, a organização ocorre dentro dele mesmo, se for um array com strings ele organiza em ordem alfabética
- asort() -> para ordenar de forma crescente os valores de um array associativo, funciona como o sort()
- arsort() -> para ordenar de forma decrescente os valores de um array associativo, funciona como o rsort()
- ksort() -> para ordenar de forma crescente as chaves de um array associativo, funciona como o sort()
- krsort() -> para ordenar de forma decrescente as chaves de um array associativo, funciona como o rsort()
- array_reverse() -> retorna um array invertido, não mexe na estrutura original do array, ou seja, precisamos armazenar seu valor em uma variável, é passado apenas o array como argumento
- shuffle() -> reorganizar os itens de um array de forma aleatória, passamos o array como parâmetro, é retornado o próprio array, ou seja, muda a estrutura original do array 
- array_sum() -> soma todos os itens de um array, retorna a soma de todos os valores numnéricos do array, é passado o array como argumento e é retornado a soma de tudo, o que não for número é ignorado pela função 
- array_merge() -> podemos unir arrays com essa função, é passado por parâmetro um número indeterminado de arrays 
- array_diff() -> verifica a diferença entre dois ou mais arrays, aceita um número indeterminado de arrays como parâmetro, a ideia é sempre o que tem de diferente no primeiro array que passei com os demais arrays que foram passados EX: array_diff($arr1, $arr2) // retornará apenas os valores do $arr1 que não fizerem intersecção com o $arr2
- array_filter() -> para filtrar elementos do array de alguma forma, geralmente é passado o array como parâmetro e mais uma função que vai expressar uma condição a ser seguida para retornar o valor EX: $retorno = array_filter($array, "funcao")
- max() -> retorna o valor máximo dentro de um array, é passado o array como parâmetro e é retornado apenas o maior valor que estiver dentro desse array
- min() -> retorna o valor mínimo dentro de um array, é passado o array como parâmetro e é retornado apenas o menor valor que estiver dentro desse array
- date() -> essa função recebe o parâmetro que vai ser a formatação da data, pega a data atual do sistema EX: date("d/m/y")
- strtotime() -> recebe uma string como parâmetro e tenta transformar essa string em uma data EX: date('d/m/y', strtotime('+2 years')) // 2 anos a mais na data atual
- mktime() -> recebe como parâmetro: hora, minuto, segundo, mês, dia e ano e criar uma data a partir dessas informações que foram passadas EX: $data = mktime(02, 12, 33, 02, 05, 1991) -> date('d/m/y', $data)
- DateTime() -> permite tratar a data como um objeto, é possível passar um parâmetro que será a data criada, retorna um array, porém, não é possível acessar suas propriedades apenas instanciando esse objeto 
- format() e modify() -> pertence a classe DateTime e ajuda a manipular os dados do objeto intanciado, format -> formata a data e modify() -> altera a data
- setDate() e setTime() -> dois métodos interessantes para se usar com o DateTime, setDate() -> recebe ano, mês e dia, altera completamente a data e setTime() -> rece hora, minuto e segundo, altera completamente o tempo da data
- diff() -> método para calcular a diferença entre duas datas, para fazer a comparação é necessário que as duas data esjam instanciadas com o DateTime EX: $dataA->diff($dataB)
- date_default_timezone_set() -> recebe um fuso horário como parâmetro

//////////////////////////////////////////////////////////////////////////////////////////////////

PHP é case sensitive para variáveis, mas, para instruções não
- echo = ECHO
- $nome != $NOME

- espaço em branco no PHP é ignorado

//////////////////////////////////////////////////////////////////////////////////////////////////

Palavras reservadas
- Exemplos: echo, insteadof, else, interface, protected, require, and, public, __DIR__, __FILE__, endif, print, private, namespace, pow, as, break, case, for, finally, switch, throw...

//////////////////////////////////////////////////////////////////////////////////////////////////

Tipos de dados

- Inteiros
-- são os números que não possuem vírgula
-- podem ser negativos também
-- para validar se um número é inteiro usamos a função is_int()

- Float
-- são os números que possuem vírgula
-- podem ser negativos também
-- para validar se é um float usamos a função is_float()

- String
-- é possível escrever textos com aspas simples ou duplas
-- as aspas duplas interpretam variáveis as simples não
-- para validar se é uma string usamos a função is_string()
-- uma string dentro do PHP é vista como um array, para percorrer cada uma das letras dela basta usar a 'variável[contador]'
-- para fazer a contagem de letras de uma string utilizar sempre a função 'strlen()'
- strtoupper() -> transforma o que for passado como parâmetro para letras maiúsculas
- strtolower() -> transforma o que for passado como parâmetro para letras maiúsculas

- Boolean
-- é um tipo de dado que possui dois valores (true or false)
-- alguns valores são considerados falsos: 0, 0.0, "0", [], NULL
-- booleano é usado para fazer validações
-- para verificar se é um booleano é usado a função is_bool()

- Array
-- serve para agrupar um conjunto de valores
-- é possível inserir qualquer tipo de dado dentro do array
-- é definido com os valores dentro de colchetes [] e seus dados separdos por vígula , EX: [1, 2, 3, 4]
-- todos os valores de um array possuem um índice, começando sempre do 0

- Array Associativo
-- é basicamente um array que possui uma chave e um valor
-- a estrutura é igual mas será construído dessa maneira: $arr = ['nome' => 'Felipe', 'idade' => 19] chave entre aspas, seta para apontar o valor e o valor

- Objetos
-- no PHP é possível criar classes e objetos
-- o objeto possui métodos que são suas ações e propriedades que são suas características

- NULL
-- esse tipo de dado tem apenas um valor, NULL
-- um uso para esse tipo de dado é verificar se uma variável está ou não vazia
-- podemos verificar se um valor é NULL com a função is_null()

//////////////////////////////////////////////////////////////////////////////////////////////////

Variáveis
- salvar um valor na memória
- em PHP as variáveis começam com $
- variáveis de variáveis, usando $$ você cria uma variável a partir de outra com o nome do valor dessa variável
- variável por referência "ponteiro" utiliza o símbolo =& se alterar o valor da uma altera o valor da outra também

------------------------------------

- Escopo da Variável

-- local: variável declarada em uma função
--- seu escopo é definido dentro da função
--- não é acessível fora da mesma
--- o seu valor é sempre resetado quando a função é finalizada 
--- cada função poderá mexer com a mesma variável, porém, seu escopo será dentro da função, ou seja, quando a função acabar a variável voltará para seu valor global

-- global: variáveos declaradas fora de funções
--- é declarada fora de funções
--- não são acessíveis dentro de funções
--- é necessário utilizar a palavra global para conseguir utilizar a variável dentro de outra função, porém, utilizando dessa forma, se o valor for alterado localmente ele será alterado globalmente também, essa instrução global deve ser usada dentro da função que quero utilizar a variável

-- static: variável declarada dentro da função, porém o seu valor permanece salvo entre chamadas da função
--- declarada com a instrução static
--- o valor da mesma é mantido e alterado a cada execução de uma função
--- é interessante esse comportamente pois as variáveis de escopo local sempre são resetadas, mas nesse caso não, nesse caso o valor persiste

-- parâmetros da função: variáveis passadas para uma função, podendo ser utilizadas ao da mesma
--- este recurso ajuda a criar funções com valores dinâmicos, podendo ser alterado a cada vez que a função é chamada
--- é possível passar mais de um parâmetro para a função

//////////////////////////////////////////////////////////////////////////////////////////////////

Expressões e Operadores
- o PHP em certas operações muda o tipo de dado de uma variável
- soma: +
- subtração: -
- divisão: /
- multiplicação: *
- por exemplo 5/2 = 2.5 (gera um float)
- 5 . 5 resulta em 55 (gera uma string, o . é para concatenação)
- sempre tomar cuidado com as expressões, pois, às vezes podem gerar resultados indesejados
- este recurso é chamado de auto cast (mudar de forma implícita o tipo da variável)
- % usado para retornar o resto de uma divisão
- ** operador de exponenciação
- . operador de concatenação
- ++ auto incremento e -- auto decremento

- Operadores de comparação
-- igualdade: == -> apenas valor é levado em consideração
-- idêntico a: === -> tipo também é levado em consideração
-- diferença: != -> apenas valor é levado em consideração
-- não idêntico a: !== -> tipo também é levado em consideração
-- maior e maior ou igual a: > e >=
-- menor e menor ou igual a: < e <=

- Operadores lógicos
-- operador AND: && -> verdade quando os dois lados forem verdadeiros
-- operador OR: || -> verdade quando pelo menos um dos lados forem verdadeiros (barra vertical ou pipe)
-- operador NOT: ! -> usado para inverter o valor booleano do que acompanha

- Operadores de conversão (cast)
-- quero que uma expressão retorne um inteiro uso (int) antes da expressão
-- para usar o cast basta apenas colocar entre parênteses o tipo de dado que quer que retorne EX: (int), (float), (string)...

- Operadores de atribuição
-- = que é o mais conhecido que atribui um valor para uma variável
-- += faz o valor da variável mais outro valor colocado
-- -= faz o valor da variável menos outro valor colocado
-- *= faz o valor da variável vezes outro valor colocado
-- /= faz o valor da variável dividio por outro valor colocado
-- %= faz o resto do valor da variável pelo valor colocado

- Operador ternário
-- como se fosse um if/else mais simplificado
-- comparação ? true : false
-- o dois pontos é opcional

//////////////////////////////////////////////////////////////////////////////////////////////////

Estruturas de controle 
- if -> tem uma condição se verdadeira ele executa o código que estiver no bloco de códigos da estrutura
- else if -> é igual um if, mas, com uma nova condição caso a primeira não seja verdadeira
- else -> não possui condição, executa se nenhuma condição for verdadeira
- pode haver um if dentro de outro

- switch -> bem parecida com o if, porém não há a pssibilidade de comparações, é comparada a um valor fixo
- case -> são os valores que serão comparados pela variável pega pelo switch
- break -> break é usado para parar um case e para sair do switch, se não colocar há a possibilidade de ele entrar em todos os cases 
- default -> é como se fosse um else, se nenhum case for atendido ele executa o default

//////////////////////////////////////////////////////////////////////////////////////////////////

Estruturas de repetição
- while -> enquanto uma condição for verdadeira ele repetirá isso, é necessário sempre alterar a variável que está sendo comparada para ter um stop do loop

- do while -> ele executa uma vez pelo menos o código antes de fazer a comparação para sair do loop

- for -> contador, condição e incremento/decremento todos na mesma linha, mais organizado e mais utilizado

- foreach -> funciona somente com um array, se repete para cada item de um array

- break -> usado para quebrar o loop antes de seu fim, para isso fazer uma condição que queira para quebrar sua repetição
- continue -> pula a execução de um loop, ou seja, ele pula e vai pra próxima repetição do loop
- pode haver um loop dentro de outro

//////////////////////////////////////////////////////////////////////////////////////////////////

Inlude
- com o include inserimos um arquivo PHP ou até um HTML
- pode ser usado tudo que está declarado no arquivo incluído
- o include não gera erro fatal se o arquivo não existir, ou seja, não prejudica a execução scrypt, continua executando mesmo assim, gera apenas um warning e esse warning pode ser ocultado
- include_once é a mesma coisa porém impede que você faça o include do mesmo arquivo mais de uma vez - mais recomendado

Require
- com o require inserimos um arquivo PHP ou até HTML
- pode ser usado tudo que está declarado no arquivo incluído
- o require gera erro fatal, então se o arquivo não existir o scrypt irá parar
- require_once é a mesma coisa porém impede que você faça o require do mesmo arquivo mais de uma vez - mais recomendado

- include_once e require_once se entendem então mesmo que faça o include_once de um arquivo e depois tente usar o require nesse mesmo arquivo ele não irá permitir

* Para voltar um diretório é bom sempre colocar dessa maneira "include __DIR__ . '/../caminho_para_o_arquivo'", require é a mesma coisa

//////////////////////////////////////////////////////////////////////////////////////////////////

Short tags
- <? código ?> -> tem alguns servidores que não suportam
- não é bom usar, apenas saber que existe

//////////////////////////////////////////////////////////////////////////////////////////////////

Exibição de conteúdo
- <?= "teste" ?> -> usado para exibir um conteúdo na tela, é um echo encurtado, para exibições rápidas, não aceita códigos dentro

//////////////////////////////////////////////////////////////////////////////////////////////////

Inserindo PHP ao HTML
- uma das principais funcionalidades do PHP
- é possível inserir códigos dinâmicos entre as tags
- esse tipo de arquivo pode ser tanto .php quanto .phtml (.phtml pode dar conflito em alguns servidores, melhor usar .php mesmo)

//////////////////////////////////////////////////////////////////////////////////////////////////

Funções
- são blocos de códigos que possuem nomes
- realizam alguma ação e podem ser reaproveitadas durante o código
- é possível passar parâmetros para funções, que moldam a execução
- reduz a duplicidade
- melhora a manutenção do código
- o PHP possui diversas funções prontas, que podemos utilizar
- parâmetro são como variáveis, utilizados dentro da função, para moldar a execução
- não há limite de parâmetros
- se passar menos argumentos do que uma função aceita gera um fatal error, se passar mais argumentos do que uma função aceita ele ignora os argumentos que não forem utilizados, utilizará sempre na ordem que for passado meu parêmetro
- para invocar a função, utilizar seu nome no código, dessa forma já estará invocando a função+
- normalmente as funções utilizam a instrução 'return' para retornar algo para onde ela foi chamada
- funções tem escopo local, porém, se usarmos a instrução global em uma variável global mas dentro da função conseguimos também usar seu valor e alterá-lo, assim como temos a instrução static, que serve para manter o valor da variável depois que a função termina já que quando não usamos isso a variável é resetada ao final da função
- é possível passar parâmetros que já possuem um valor pré-definido, ou seja, caso não haja uma passagem de valor esse valor default é atribuído
- a função será executada normalmente com o valor definido EX: function teste($a = "padrão")
- se a função tiver mais de um parâmetro e um deles for obrigatório e o outro tiver um valor default pe interessante sempre colocar o default por último, já que se colocar ele antes de um parâmetro obrigatório ele acaba se tornando um parâmetro obrigatório também
- func_get_arg -> retorna uma lista com os argumentos de uma função -> basta apenas colocar ela dentro da função que ela já pega a lista de argumentos que estão sendo passados, não precisa de parâmetros dentro dela
- func_num_args -> retorna o número de argumentos de uma função -> basta apenas colocar ela dentro da função que ela já pega o número de argumentos que estão sendo passados, não precisa de parâmetros dentro dela
- uma função pode também retornar uma lista de valores, não apenas um valor específico e aí acessar os índices de cada elemento da lista

//////////////////////////////////////////////////////////////////////////////////////////////////

Strings
- é possível interpolar variáveis em strings de duas formas, interpolar é mostrar o valor da variável dentro de uma string
- utilizando aspas duplas e colocando a variável e também com chaves e o nome da variável, não tem difenrença em ambas as formas EX: "Interpolando a variável $teste", "Interpolando a variável {$teste}"
- ideal é que no seu programa você mantenha sempre a mesma sintaxe, se começou com chaves continua com chaves até o final, se começou sem chaves continua sem chaves até o final
- há valores de escape que podem ser utilizados, isso só funciona com aspas duplas, se for simples não funciona pois ele não interpola EX: \\ para mostrar uma barra invertida, \t = tab, \$ = sinal do dólar, \n = nova linha
- são usados apenas para mostrar em telas de texto pura, no HTML não funciona
- print() -> é igual ao echo, porém é uma função e irá mostrar o que estiver dentro de seus parênteses
- printf() -> igual a linguagem C, e tem a mesma funcionalidade que a função print, porém para imprimir algo é preciso colocar símbolo de porcentagem acompanhado do tipo de dado que será impresso EX: printf("Número %d", $var) -> %d para números inteiros 
- strlen() -> para ter o retorno do número de caracteres que tem em uma string apenas a string é passada como parâmetro para essa função
- para acessar cada um dos caracteres da string basta percorrer a string como se fosse um array
- é possível remover espaçoes em branco de uma string com algumas funções
- trim() -> limpa espaços antes e depois da string, é passado a string como parâmetro para ele
- ltrim() -> limpa os espaços da esquerda da string (left trim), é passado a string como parâmetro para ele
- rtrim() -> limpa os espaços da direita da string (right trim), é passado a string como parâmetro para ele
- strtoupper() -> transforma o que for passado como parâmetro para letras maiúsculas
- strtolower() -> transforma o que for passado como parâmetro para letras minúsculas
- ucfirst() -> altera a primeira letra da string para maiúscula, é passado a string como parâmetro
- ucwords() -> altera a primeira letra de cada palavra da string para maiúscula, é passado a string como parâmetro
- strip_tags() -> altera uma string poluída, por exemplo, com tags HTML para uma string com apenas textos, é passado a string como parâmetro da função
- substr() -> função para pegar uma parte específica de uma string, (str, ini, fim) str = string que você tem, ini = índice que inicia o que você quer pegar, fim = número de caracteres que precisa pegar a partir do início, se omitir o fim ele pega a partir do ini até o final da string e se o fim for negativo ele pega o final da string menos o número de caracteres que foi passado, então se fim = -3 ele pega o fim menos os 3 últimos caracteres
- strrev() -> inverte uma string, é passado a string como parâmetro e ela é invertida
- str_repeat() -> usado para repetir a string, é passado por parâmetro a string e o número de vezes que se repetirá
- explode() -> usado para transformar a string em um array, é passado a string como parâmetro e o delimitador para se criar os índices EX: (" ", "Teste Teste") o delimitador é o espaço, converterá essa string em um array com dois índices [0] => Teste, [1] => Teste
- implode() -> usado para transformar um array em uma string, é passado o separador e o array para se criar a string EX: (" ", ["Teste", "Teste"]) o separador é o espaço e o array é o que vem depois
- strpos() - podemos encontrar algum texto na string, se recebermos algum valor é que o texto foi encontrado, e este valor é o índice inicial, se retornar false, o texto procurado não existe na string, é passado a string como parâmetro e o texto que quero achar dentro da string, ele procura também uma parte da string não precisa ser uma palavra inteira
- strrpos() - igual ao strpos(), mas, esse encontra a última ocorrência de um texto na string, o strpos() retornava o primeiro que ele achava que saciasse aquele texto passado, o strrpos() retorna o último que sacia
- geralmente o strpos é usado junto com a substr(), pois um retorna o índice e o outro pega a palavra EX: $pegaPalavra = substr($str, strpos($str, "teste"), 5);
- strstr() -> usado para retornar a partir de um ponto da string até o final dela, é passado a string como parâmetro e a partir de onde ele irá pegar, EX: strstr($str, "resto"), vai pegar desde resto até o final da string, ou irá retornar false se não achar aquela string
- parse_url() -> usado para decompor uma URL, recebemos um array associativo com todas as partes que a URL tem, alguns elementos que podem ser retornados são: protocolo, host, parâmetros

//////////////////////////////////////////////////////////////////////////////////////////////////

Arrays 
- para adicionar um item ao fim do array, basta colocar o nome do array com colchetes atribuindo o valor, EX: $arr[]  valor
- range() -> função para criar um array rapidamente, basta passar como parâmetros o valor inicial, o valor final e se quiser o passo que ele irá, se essa última informação for ignorada ele fará de 1 em 1
- count() -> retorna o número de elementos de um array, é passado o array como parâmetro para essa função
- podemos criar um array multidimensional, também conhecido como matriz
- para acessar elementos desses arrays também é por meio de índices EX: $arr = [ [1, 2, 3], [2, 4, 6] ] é como se colocasse outros dois arrays dentro de um único array e para acessar o elemento basta colocar seus índices EX: $arr[1][2] // elemento de valor 6
- para imprimir o array interno com o for podemos usar o count($arr[$i]) -> isso irá contar os elementos do array que está dentro do outro array
- podemos criar outras variáveis com base em um array
- list() -> usado para desconstruir um array, é passado por parâmetro as variáveis que quero criar e na frente o array que uero pegar as informações EX: list($nome, $idade, $profissao) = $pessoa
- array_slice() -> podemos resgatar uma faixa de elementos, é passado 3 parâmetros para essa função, sendo o array, o índice inicial e número de elementos que queremos resgatar, assim como o substring se o último parâmetro for omitido ele pega até o final do array e se o parâmetro for negativo ele pega do final menos o número de elementos que foi passado
- array_splice() -> remover elementos de um array, passado como parâmetro o array, índice inicial e quantos elementos queremos remover, igual o slice, importante, o próprio array se ajusta para os índices ficarem na ordem certa
- array_chunk() -> dividir um array grande em diversos arrays de número de elementos iguais, passamos o array e o número de elementos que cada array deve ter
- array_keys() -> usado no array associativo, retorna as chaves do array em formato de outro array, é passado por parâmetro apenas o array associativo
- array_values() -> usado no array associativo, retorna os valores do array em formato de outro array, é passado por parâmetro apenas o array associativo
- array_key_exists() -> verificar se uma chave específica existe dentro daquele array associativo, é passado por parâmetro a chave que quero verificar se existe e o array EX: array_key_exists("nome", $arr), retorna um booleano
- isset() -> usado também para verificar se algo existe, igual o array_key_exists(), EX: isset($arr['nome']), verifica se a chave nome existe dentro do array, usado para variáveis também
- extract() -> criar variáveis com o array associativo, igual o list, mas esse é para arrays associativos, o nome da chave será o nome da variável, se houver uma variável com o mesmo nome da chave a mesma será sobrescrita pelo valor que tiver no array, é passado apenas o array como parâmetro
- compact() -> podemos criar um array a partir de variáveis, onde o nome da variável será a chave e seu valor o valor mesmo, é passado por parâmetro as variáveis porém, em forma de string, EX: $carro = compact("marca", "motor") // as variáveis eram ($marca, $motor)
- foreach() -> para arrays associativos podemos usar a notação (chave => valor) para acessar rapidamente um valor no array associativo, para arrays normais é passado por parâmetro o array e um nome qualquer que vai ser o valor de cada índice, já para arrays associativos é passado o array mais um nome qualquer que representa a chave => um nome qualquer que representa o valor
- array_reduce() -> tem como objetivo reduzir um array a apenas um valor, geralmente é usado uma segunda função dentro dessa função para que algum processo seja executado e fique apenas um valor EX: function soma($a, $b) { return $a + $b; } array_reduce($arr, "soma") // ele vai somar todos os índices do array e retornar o resultado
- in_array() -> verifica se um item passado por parâmetro está no array, é passado o item e o array como parâmetros, o retorno é um booleano true se encontrar o item e false se não encontrar
- sort() -> ordenar de forma crescente um array, é passado por parâmetro o array que queremos ordenar, não é preciso colocá-lo dentro de outra variável, a organização ocorre dentro dele mesmo, se for um array com strings ele organiza em ordem alfabética
- rsort() -> ordenar de forma decrescente um array, é passado por parâmetro o array que queremos ordenar, não é preciso colocá-lo dentro de outra variável, a organização ocorre dentro dele mesmo, se for um array com strings ele organiza em ordem alfabética
- asort() -> para ordenar de forma crescente os valores de um array associativo, funciona como o sort()
- arsort() -> para ordenar de forma decrescente os valores de um array associativo, funciona como o rsort()
- ksort() -> para ordenar de forma crescente as chaves de um array associativo, funciona como o sort()
- krsort() -> para ordenar de forma decrescente as chaves de um array associativo, funciona como o rsort()
- array_reverse() -> retorna um array invertido, não mexe na estrutura original do array, ou seja, precisamos armazenar seu valor em uma variável, é passado apenas o array como argumento
- shuffle() -> reorganizar os itens de um array de forma aleatória, passamos o array como parâmetro, é retornado o próprio array, ou seja, muda a estrutura original do array 
- array_sum() -> soma todos os itens de um array, retorna a soma de todos os valores numnéricos do array, é passado o array como argumento e é retornado a soma de tudo, o que não for número é ignorado pela função 
- array_merge() -> podemos unir arrays com essa função, é passado por parâmetro um número indeterminado de arrays 
- array_diff() -> verifica a diferença entre dois ou mais arrays, aceita um número indeterminado de arrays como parâmetro, a ideia é sempre o que tem de diferente no primeiro array que passei com os demais arrays que foram passados EX: array_diff($arr1, $arr2) // retornará apenas os valores do $arr1 que não fizerem intersecção com o $arr2
- array_filter() -> para filtrar elementos do array de alguma forma, geralmente é passado o array como parâmetro e mais uma função que vai expressar uma condição a ser seguida para retornar o valor EX: $retorno = array_filter($array, "funcao")
- max() -> retorna o valor máximo dentro de um array, é passado o array como parâmetro e é retornado apenas o maior valor que estiver dentro desse array
- min() -> retorna o valor mínimo dentro de um array, é passado o array como parâmetro e é retornado apenas o menor valor que estiver dentro desse array

//////////////////////////////////////////////////////////////////////////////////////////////////

Orientação a Objetos
- objetos que são entidades que possuem comportamentos (métodos/funções) e características (atributos/propriedades/variáveis)
- objetos interagem entre si e sistemas são escritos orientados a objetos
- classes são "moldes" de um objeto, sempre que precisar instanciar um objeto é necessário uma classe, a classe contém seus métodos e suas propriedades
- é possível mudar o valor para cada objeto criado, mas ele parte do que a classe impõe
- para iniciar uma classe é necessário usar a a palavra "class" e dar um nome a essa classe, por padrão sempre utilizamos a primeira letra em maiúsculo no nome da class
- para instanciar um objeto é necessário utilizar a palavra "new" em conjunto do nome da classe 
- a partir daí uma entidade com as características da classe será criada, normalmente é normal encapsular isso em uma variável EX: $pessoa = new Pessoa()
- para declarar um método vamos utilizar a sintaxe de function, porém dentro da classe, é uma função normal igual já foi visto antes
- para acessar um método por exemplo da classe a partir de um objeto basta colocar o nome do objeto + -> + o que quer acessar EX: $pessoa->falar();
- propriedades são basicamente variáveis dentro de uma classe, porém, as variáveis tem uma visibilidade dentro da class, podendo ser public, private ou protected
- this se refere a instância atual do objeto, se refere basicamente ao objeto atual, usado dentro da própria classe geralmente, assim você generaliza os métodos podendo chamar eles para qualquer instância
- contantes são parecidas com variáveis, porém seus valores não são alterados durante a execução do programa 
- constantes costumam ter seu nome todo em maiúsculo, assim fazemos para separar variáveis normais de constantes, não é necessário o cifrão para fazer a declaração e para acessar uma constante usa-se '::' no lugar de '->' EX: public const CHAVE_API = "api_teste" // para acessar basta usar :: EX: $conexao::CHAVE_API
- para acessar dentro da classe no lugar de 'this' usa-se 'self' EX: self::NOME_CONSTANTE
- public: a propriedade ou método pode ser acessada de qualquer forma, por qualquer um
- protected: a propriedade ou método pode ser acessada apenas pela classe de origem ou as que a recebem por herança
- private: a propriedade ou método poder ser acessada apenas pela classe que foi criada 
- herança é o recurso que permite com que uma classe filha herde propriedades e métodos de uma classe pai, a palavra reservada utilizada para isso é a 'extends'
- para checar a ancestralidade de uma classe ou objeto é usado o 'instanceof' EX: $pessoa instanceof Humano // isso irá retornar um booleano 
- interfaces também são modelos de definição de uma classe, toda classe ue implementar uma interface, será obrigada a implementar suas propriedades e métodos, é utilizada a palavra 'implements', ma interface nenhum método ou propriedade são definidos, estão lá apenas para forçar a classe que implementar essa interface a também implementar aquelas propriedades e métodos 
- para criar a interface é igual uma class, porém , no lugar de colocar 'class nome_class' vai ser 'interface nome_interface'
- traits permitem o uso do código sem hieraruia de classes, ou seja, sem herança, podemos assim utilizar os métodos da classe ue foi feita a trait, é utilizada a palavra reservada 'use', para mostrar que será uma trait é como declarar a class, porém, temos que colocar 'trait nome_trait', para usar basta colocar dentro da classe que você quer utilizar 'use nome_trait'
- classes abstratas não podem ser instanciadas, podemos ter métodos abstratos, que devem ser implementados obrigatoriamente pela classe que herda a abstrata, a palavra reservada é 'abstract' EX: abstract class ClasseAbstrata {}
- construtores, basicamente é inicializar os objetos com alguns valores pre definidos e passar valores únicos para cada objeto, para criar esse método, basta inicializar o construtor com '__construct'
- classes anônimas são criadas em uma variável e não possuem nome, funcionam como qualquer outra classe e essa é preciso fechar com ';' EX: $anonima = new class() { código };
- class_exists() -> verifica se uma classe existe, é passado uma classe como parâmetro e recebe um booleano de volta EX: class_exists("Humano")
- get_class_methods() -> passa uma classe por parâmetro e recebe seus métodos como resposta, recebe um array com os métodos EX: get_class_methods("Humano")
- get_class_vars() -> passa uma classe por parâmetro e recebe suas propriedades como resposta, recebe um array com as propriedades EX: get_class_vars("Humano")
- is_object() -> verifica se uma variável é um objeto, retorna um booleano EX: is_object($var)
- get_class() -> verifica a qual classe aquele objeto pertence, retorna a classe a qual esse objeto pertence EX: get_class($var)
- method_exists() -> verifica se um método existe em um objeto EX: method_exists($var, "nome_metodo")

//////////////////////////////////////////////////////////////////////////////////////////////////

Datas
- date() -> essa função recebe o parâmetro que vai ser a formatação da data, pega a data atual do sistema EX: date("d/m/y")
- strtotime() -> recebe uma string como parâmetro e tenta transformar essa string em uma data EX: date('d/m/y', strtotime('+2 years')) // 2 anos a mais na data atual
- mktime() -> recebe como parâmetro: hora, minuto, segundo, mês, dia e ano e criar uma data a partir dessas informações que foram passadas EX: $data = mktime(02, 12, 33, 02, 05, 1991) -> date('d/m/y', $data)
- DateTime() -> permite tratar a data como um objeto, é possível passar um parâmetro que será a data criada, retorna um array, porém, não é possível acessar suas propriedades apenas instanciando esse objeto 
- format() e modify() -> pertence a classe DateTime e ajuda a manipular os dados do objeto intanciado, format -> formata a data e modify() -> altera a data
- setDate() e setTime() -> dois métodos interessantes para se usar com o DateTime, setDate() -> recebe ano, mês e dia, altera completamente a data e setTime() -> rece hora, minuto e segundo, altera completamente o tempo da data
- diff() -> método para calcular a diferença entre duas datas, para fazer a comparação é necessário que as duas data esjam instanciadas com o DateTime EX: $dataA->diff($dataB)
- é possível usar os operadores de com paração para comparar duas datas diferentes, ou seja, ver se uma data está mais a frente futuramente que outra ou mais no passado que a outra ou se as duas estão no mesmo dia 
- date_default_timezone_set() -> recebe um fuso horário como parâmetro

//////////////////////////////////////////////////////////////////////////////////////////////////

PHP e a WEB 
- Requisições PHP
-- GET -> solicita a apresentação de um recurso (ex: visualização de uma página)
-- POST -> envio de dados ao servidor (ex: cadastro de usuário)
-- PUT -> atualização de dados 
-- DELETE -> remoção de dados
-- PATCH -> atuaização de dado específico 

- para conseguir lidar com essas requisições o PHP fornece algumas variáveis globais
-- $_ENV -> variáveis de ambiente
-- $_GET -> parâmetros que foram enviados através da request GET, ou seja, pela url 
-- $_POST -> parâmetros que foram enviados por POST
-- $_COOKIE -> valores de cookies
-- $_SESSION -> como se fosse um cookie mas é melhor para salvar alguns dados
-- $_SERVER -> informações sobre o servidor 
-- $_FILES -> informações sobre os arquivos que vieram por upload

- $_SERVER 
-- SERVER_SOFTWARE -> identificação do servidor, saber qual software ta rodando no servidor
-- SERVER_NAME -> Hostname, DNS ou IP do servidor
-- SERVER_PROTOCOL -> protocolo do servidor 
-- SERVER_PORT -> porta do servidor 
-- QUERY_STRING -> argumentos após o ? na url

- processamento de formulários, há duas maneiras desse processamento, via GET e via POST, o GET processo a query string, ou seja, na url, com o POST processamos as informações que vem na requisição, não aparecem na url 
- exemplo de uso é: GET = buscas e POST = registro de usuário

- é possível criar uma página que faz o processamentos dos dados e também exibe o input de informações 
- para isso é necessário criar um if que checa o método de requisição e a partir disso criar variações ($_SERVER['REQUEST_METHOD'])

- para receber um array de inputs marcados em um checkbox por exemplo, basa colocar o name com '[]' depois dele, e colocar o mesmo name pra todos, name="caracerisicas[]"

- Upload de arquivos
-- primeiro alerar o atributo enctype do formuláio para: multipart/form-data
-- necessário também um input do tipo file
-- o tamanho do arquivo pode exaurir a memória do servidor, colocar sempre um tamanho máximo de arquivo para não correr esse risco
-- quando enviado o formulário  global $_FILE terá as informações do arquivo que foram enviados 
-- $_FILE -> é possível o tamanho do arquivo que o usuário subiu, assim conseguindo manejar o tamanho do arquivo para não pesar no servidor 

- Validação de formulários
-- É possível fazer validações com JS e HTML, porém, não é bom deixar essas validações apenas com eles, pois, o front-end é facilmente manipulável

- $_COOKIE 
-- strings que contém informações 
-- setcookie() -> para adicionar um cookie 
-- a função deve ser chamada antes do corpo da página, o envio de dados é através do header (cabeçalho)
-- cookie leva dados como: nome, valor e data de expiração

- $_SESSION
-- é possível criar uma variável que persiste em diferentes páginas e perdura por várias visitas ao mesmo site 
-- utiliza recursos de cookies para funcionar e se o recurso estiver desabilitado propaga a sessão via url 
-- são utilizadas para: verificação, carrinho de compras e tudo o que precisa persistir de página em página
-- mais utilizado que o cookie 
-- sessions são salvas em arquivos no computador que estamos ou no servidor da aplicação
-- esses arquivos são salvos em php.ini na configuração session.save_path
-- as sessions podem ser salvas em dois formatos: o ptóptio do PHP e também o Web Distributed Data eXchange (WDDX)
-- toda página deve ter 'session_start()' para que as sessions sejam inicializadas naquela página
-- a session basicamente salva o id da sessão nos cookies e busca as informações dentro daquele arquivo que está salvando as sessions

- SSL Secure Sockets Layer
-- o PHP não se importa muito e não tem vantagens sobre o SSL 
-- porém garantimos que as requisições de dados entre nosso site e servidor estejam mais seguras com a encriptação dos dados 
-- devemos apenas ter cuidados com os formulários, para que sejam enviados para a url com HTTPS, pois, alguns servidores bloqueiam a conexão HTTP
-- Cloudflare -> é um software que disponibiliza certificado ssl gratuito, sempre colocar para maior segurança dos dados, um e-commerce por exemplo não aceitaria pagamentos se não tivesse uma certificação
-- para dados de formulários é muito importante essa certificação e sempre verificar se está sendo enviado os dados para o domínio certo 